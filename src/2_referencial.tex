\chapter[Referencial Teórico]{Referencial Teórico}
\label{cap:referencial}

\section{Android}
\label{sec:android}

Android é um sistema operacional (SO) de código aberto e livre utilização para diversos tipos de dispositivos e um projeto de código aberto liderado pela Google  \cite{androidAndroidOpenSource}. 
Sendo assim, qualquer companhia que tenha interesse em utilizar um SO pronto para seus dispositivos pode utilizar o Android e adaptá-lo aos seus padrões internos de qualidade e usabilidade sem custo adicional. 
Essa abordagem gerou um grande engajamento da comunidade e empresas uma vez que, atualmente, são mais de 2,5 bilhões de dispositivos ativos que utilizam alguma forma desse SO. 

De maneira a demonstrar a versatilidade do sistema, suas categorias de dispositivos são: smartphones, tablets, TVs, relógios de pulso e Android auto \cite{androidWhatIsAndroid}. Ademais, por ser um projeto \textit{open source} verifica-se o aumento no dinamismo de suas mudanças, tornando mais fácil o melhor atendimento ao consumidor, de modo a não restringir as inovações do SO a uma só empresa \cite{androidAndroidOpenSource}.

Na figura \ref{fig:androidStack} observa-se o \textit{Software Stack} do Android, ou a pilha de \textit{Software}, que seria a arquitetura genérica de um \textit{smartphone} que utiliza esse SO. Nela, é possível observar que a base de desenvolvimento do SO é um kernel Linux \cite{triviaTanenbaum2015modern}, que também se trata de um \textit{Software} de código aberto.

\begin{figure}[h]
    \caption{Android \textit{Software Stack}}
    \centering
    \includegraphics[width=.45\textwidth]{img/android stack info image.png}
    \fonte{\cite{androidAndroidOpenSource}}
    \label{fig:androidStack}
\end{figure}

\newpage
\subsection{Kotlin}
Kotlin é uma linguagem de programação de propósito genérico criada pela JetBrains e contribuidores \textit{open source}, que, não obstante guardar similitude com o Java, apresenta melhoria em alguns pontos considerados importantes por seus criadores. 

Ela é atualmente recomendada para as seguintes funcionalidades: \textit{data-science}, back-end, front-end e aplicações móveis nativas e aplicações móveis multiplataforma \cite{androidKotlin}. Além da própria empresa afirmar sua capacidade de desenvolvimento de aplicações móveis nativas, a Google recomenda sua utilização para desenvolvimento de aplicações Android \cite{androidKotlin-first}.

Principais características do Kotlin:
\begin{itemize}
    \item Interoperabilidade: códigos e bibliotecas 100\% compatíveis entre Java e Kotlin.
    \item Segurança: valida valores nulos em tempo de compilação, para evitar exceções em tempo de execução.
    \item Concisa: menos códigos para realizar mais funções
\end{itemize}

Conforme exposto, o Kotlin é 100\% compatível com bibliotecas Java. Então, qual o motivo de se escolher o Kotlin? A resposta está justamente nas outras duas características principais da linguagem: ela é mais segura que Java, por causa de sua validação de valores nulos em tempo de compilação, reduzindo as chances (ou mesmo eliminando, se usada corretamente) do programa ser abortado por causa de uma exceção levantada em tempo de execução; além disso, Kotlin é uma linguagem mais concisa e expressiva em comparação ao Java, logo, é possível realizar mais ações com menos código escrito \cite{androidKotlin}. Outro ponto muito importante a ser levado em consideração é que os códigos escritos em Kotlin geralmente possuem menos \textit{code smells} do que códigos escritos em Java \cite{androidKotlinVsJava}.

Portanto, é de fácil compreensão o motivo dessa linguagem ser a recomendada para o desenvolvimento de aplicações nativas Android em detrimento do Java. Somado a esse fato, o novo \textit{framework} Kotlin Multiplatform Mobile (KMM) que objetiva o desenvolvimento de aplicações móveis multiplataforma está cada vez mais robusto e já é utilizado em ferramentas internas por empresas como: Philips, Autodesk, Netflix, entre outras \cite{multiplataformaKotlinMultiplatform}.


\section{iOS}
\label{sec:ios}
O iOS é o sistema operacional criado e utilizado, exclusivamente, pela Apple Inc. em seus smartphones \cite{iosIOS14}. Uma vez que se trate de um SO desenvolvido especificamente para dispositivos da própria empresa, a integração entre \textit{hardware} e \textit{software} é bem maior e melhor construída do que em comparação ao Android \cite{iosSheikh2013smartphone}. Essa integração pode ser observada na Figura \ref{fig:iosStack}: 

\begin{figure}[h]
    \caption{Arquitetura iPhone}
    \centering
    \includegraphics[width=.65\textwidth]{img/iphoneArchitecture.png}
    \fonte{\cite{iosSheikh2013smartphone}}
    \label{fig:iosStack}
\end{figure}

Além disso, o iOS utiliza-se de uma parte do Darwin para seu \textit{kernel} \cite{triviaTanenbaum2015modern}, que se trata de outro sistema operacional desenvolvido pela Apple. Apesar de ser um SO tipo Unix, seus criadores deixaram claro que o \textit{kernel}, xnu, utilizado pelo Darwin não é Unix, uma vez que o acrônimo de xnu é \textit{"X is Not Unix"} ou traduzido "X Não é Unix" \cite{iosDarwinXnu}.

\subsection{Swift}
Swift é a linguagem de programação de propósito geral criada e recomendada pela Apple para o desenvolvimento de softwares para todo o ecossistema da própria empresa, \cite{iosStartDevIos,iosSwift}. Assim como o Kotlin, realiza teste de nulidade para evitar \textit{crashs} inesperados no software. Ainda possui as seguintes características sengundo a própria Apple \cite{iosSwift}:

\begin{itemize}
  \item open source;
  \item rápida e poderosa;
  \item interoperabilidade com a linguagem Objective-C (antigamente utilizada para desenvolvimento de softwares para o ecossistema Apple).
\end{itemize}

Outro ponto relevante a ser mencionado sobre a linguagem é a possibilidade de uso da biblioteca SwiftUi que possibilita o desenvolvimento de interfaces de usuário de forma declarativa. Isso faz com que o desenvolvimento seja mais produtivo, somado à compatibilidade nativa dessa interface com todos dispositivos Apple \cite{iosSwiftUI}.


\section{Princípios de projeto}
\label{sec:principiosProjeto}
A manutenabilidade de um sistema é uma pricipais características que influenciam na qualidade de um software, quanto mais fácil é a manutenção de um sistema, maior sua qualidade \cite{arquiMonografiaKecia}. Decorrente dessa informação, três tópicos foram levantados como pontos principais para facilitar a manutenção de um projeto de \textit{software} \cite{arquiEngSoftModerna}. São eles:

\begin{enumerate}
  \item Ocultamento de Informação: define que operações dinâmicas de um módulo não devem ser conhecidas pelo cliente. Isso faz com que alterações nessas partes dinâmicas não gerem modificações nos clientes desse módulo.
  \item Coesão: assim como a própria definição da palavra, é o grau de harmonia que as operações de um módulo tem entre si \cite{triviaDicio}. Dessa forma, o módulo deveria ser resposável somente por funcionalidades que gerem somente \textbf{um} motivo para alterações nele mesmo \cite{arquiEngSoftModerna} - motivo no sentido negocial da regra, excluindo correções de bugs e alterações técnicas.
  \item Acoplamento: é a definição do nível de interdependência entre dois módulos. Quanto mais dependente um módulo é do outro, maior o acoplamento entre eles.
\end{enumerate}

Em suma, para construir um \textit{software} de boa qualidade é necessário que: oculte as informações dinâmicas de um módulo; que o módulo seja coeso internamente; e que tenha o mínimo de acoplamento com outros módulos. Para atingir esses objetivos foram criados os princípios de projetos, os quais são diretrizes mais concretas que os desenvolvedores conseguem e devem seguir. Entre os vários pricípios de projetos, serão apresentados 5 que são conhecidos como padrão SOLID \cite{arquiCleanArch}.

\subsection{\textit{Single Responsibility} - Princípio da Responsabilidade Única}
A definição do princípio da responsabilidade única é que um módulo deve ter um, e somente um, motivo para alteração. Em outras palavras o módulo deve atender a um único cliente/\textit{stakeholder} ou "grupo de interesse" \cite{arquiCleanArch}. Logo, esse princípio pode ser utilizado em diferentes níveis do software: a nível de classes e funções; a nível de componente; e, o mais importante para o estudo em questão, a nível arquitetural do software relacionando responsabilidades e os limites de cada camada da arquitetura. Além disso, o princípio condiz diretamente com a coesão de um módulo, ou seja, se for seguido, a coesão do módulo será maior \cite{arquiEngSoftModerna}.

\subsection{\textit{Open Closed} - Princípio Aberto/Fechado}
O princípio Aberto/Fechado defende que um módulo deve ser aberto para ser extendido e adptado à novas funcionalidades, contudo não deverá sofrer alterações internas para se adaptar à essas novas funcionalidades \cite{arquiCleanArch}. Para que isso ocorra é necessário que o desenvolvedor separe o módulo em componenentes de maneira a possibilitar a extensão de sua solução para o acréscimo de novas funcionalidades ao módulo sem acessar ou modificar o módulo em questão e ainda ocultar informações desnecessárias à extensibilidade do módulo.

\subsection{\textit{Liskov Substitution} - Princípio da Substituição de Liskov}
A substituição de liskov determina que classes que extendam métodos não podem quebrar os contratos dos métodos da classe extendida. Para facilitar o entendimento desse princípio segue um exemplo que quebra este princípio:

Uma classe Quadrilátero, que representa um quadrilátero qualquer, possui uma função calculaArea() que utiliza-se da equação  \begin{math}
base * altura = area\end{math} para calcular sua área, assim como demostrado no código \ref{code:quadrilatero}.

\begin{scriptsize}
\estiloJava
\begin{lstlisting}[caption={Classe Quadrilatero}, label=code:quadrilatero]
class Quadrilatero {
    int base;
    int altura;
    
    int calculaArea(){
        return base * altura
    }
    
    ...
}
\end{lstlisting}
\end{scriptsize}

Existe também uma classe Quadrado no código \ref{code:quadrado}, que, por ser um tipo específico de quadrilátero, extende a classe Quadrilatero a fim de se tornar um subtipo dessa classe. Porém, como um quadrado possui sua base igual a sua altura a equação utilizada para calcular sua área é a equação \begin{math}base * base = area\end{math}.

\begin{scriptsize}
\estiloJava
\begin{lstlisting}[caption={Classe Quadrado}, label=code:quadrado]
class Quadrado extends Quadrilatero{
    int base;
    int altura;
    
    override int calculaArea(){
        return base * base
    }
    
    ...
}
\end{lstlisting}
\end{scriptsize}

Esse cálculo não é errado para o contexto de um quadrado. Entretanto, ao se utilizar uma instância da classe Quadrado como um Quadrilátero o cáculo da área poderia dar errado, assim como representado no código \ref{code:testeQuadrado}, uma vez que a área esperada é 10, mas irá resultar 25.

\begin{scriptsize}
\estiloJava
\begin{lstlisting}[caption={Teste quadrilátero}, label=code:testeQuadrado]
void main(){
    Quadrilatero quadrilatero = new Quadrado();
    quadrilatero.setAltura(2);
    quadrilatero.setBase(5);
    
    assert(quadrilatero.calculaArea() == 10);
}
\end{lstlisting}
\end{scriptsize}

Logo, não seguir o princípio da substituição de liskov pode gerar graves problemas; e a solução que ainda ferisse o princípio, aumentaria o custo de manutenção do sistema \cite{arquiCleanArch}. 

\subsection{\textit{Interface Segregation} - Princípio da Segregação de Interface}

A Segregação de Interface é um caso específico do princípio da Responsabilidade Única. Nesse novo contexto utiliza-se de interfaces para separar funções das quais as classes precisam, a fim de que uma classe dependa de todas as operações de uma outra através das interfaces. Exemplificando: dado que uma classe A que dependa da classe B, mais especificamente a classe A utiliza um método b1 de B; contudo B possui os métodos b1 (utilizado por A) e b2 (não utilizado por A). O princípio da Segregação de Interface determina que deverá ser criada uma interface X que possua somente o método b1 para que A dependa de X que não possui métodos não utilizados por A \cite{arquiCleanArch}.

\subsection{\textit{Dependency Inversion} - Princípio da Inversão de Dependência}

A ideia que interfaces são mais estáveis do que suas respectivas implementações é a base do princípio da Inversão de Dependência. Com isso, para seguir o princípio é preferível que nenhuma classe dependa diretamente da implementação concreta de outra classe, mas sim de uma interface. A preferência é colocada no lugar da obrigatoriedade uma vez que não é possível que uma classe seja totalmente livre da dependência de implementações concretas, contudo, um software que siga ao máximo o princípio da Inversão de Dependência vai ser mais estável do que um que não o utilize \cite{arquiCleanArch}.
