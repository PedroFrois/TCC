\chapter[Arquitetura Proposta]{Arquitetura Proposta}
\label{cap:novaArquitetura}

A proposta da nova arquitetura tomou como base principalmente outras duas, a \textit{Model-View-ViewModel} (MVVM) e a \textit{Clean Architecture} \cite{arquiMVVMGoogle, arquiCleanArch}. Essas duas arquiteturas serão descritas nas seções \ref{sec:mvvm} e \ref{sec:clean}, entretanto para um melhor entendimento é recomendado a leitura referenciada de cada uma.

\section{Arquitetura \textit{Model-View-Viewmodel}}
\label{sec:mvvm}

Trata-se de uma arquitetura criada por Ken Cooper e Ted Peters, sendo atualmente recomendada pela Google para o desenvolvimento de aplicações nativas em Android. Anteriormente, até 2010, a arquitetura recomendada era a \textit{Model-View-Controller}, mas, por dificuldades de manutenção e testes, a Google passou a recomendar a MVVM ou \textit{Model-View-Presenter}. Por meio do artigo "\textit{A comparison of Android Native App Architecture MVC, MVP and MVVM}", foi realizada a comparação entre as 03 (três) arquiteturas, ocasião na qual conclui-se que tanto a MVVM quanto MVP possuem ganhos significativos quando comparadas com a MVC. Já entre MVVM e MVP, não houve uma resposta clara acerca de qual seria a melhor, mas foi concluído que MVVM é mais facilmente testável, enquanto a MVP tinha uma manutenibilidade melhor \cite{arquiMVVM, arquiMVVMGoogle}.

Dado o exposto, tem-se que a escolha entre MVVM e MVP se baseiam no domínio do problema e no consenso entre os desenvolvedores a respeito de qual característica é a mais relevante para seu projeto. Todavia, sistemas em que testes são realizados mais facilmente são melhor testados, logo, possuem menos erros críticos em produção, de forma que as manutenções que serão realizadas para correção de tais erros dispõem de um tempo maior. Deste modo, a arquitetura MVVM foi a escolhida para ser utilizada como uma das inspirações dessa nova arquitetura que será apresentada na subseção \ref{sec:description}.

A representação de alto nível da arquitetura pode ser observada na Figura \ref{fig:mvvm}. A partir dela, é possível compreender que a \textit{View} e a \textit{ViewModel}, representados, respectivamente, na figura por \textit{Activity/Fragment} e \textit{ViewModel}, são responsáveis pela visualização e lógica de visualização do software. Já o agrupamento do \textit{Repository}, \textit{Model} e \textit{Remote Data Source} gerenciam as partes de modelo de dados, regras de negócio e requisição de dados local e remoto. Esse agrupamento foi abstraído para o nome \textit{Model}, que está presente no nome da arquitetura. 


\begin{figure}[h]
    \caption{Arquitetura Model-View-Viewmodel}
    \centering
    \includegraphics[width=.85\textwidth]{img/mvvm.png}
    \fonte{\cite{arquiMVVMGoogle}}
    \label{fig:mvvm}
\end{figure}


\section{Arquitetura Limpa - \textit{Clean Architecture}}
\label{sec:clean}

A \textit{Clean Architecture} ou Arquitetura Limpa foi desenvolvida por Robert Martin \cite{arquiCleanArch} tem como foco a \textit{Separation of Concerns}, ou Separação de Conceitos, fazendo com que todos os conceitos SOLID explicados anteriormente sejam seguidos. Ademais, promove a "[...] implementação de sistemas que favorecem reusabilidade de código, coesão, independência de tecnologia e testabilidade." \cite{arquiEngSoftModerna}.

Essa arquitetura utiliza-se de outras arquiteturas conhecidas como: Arquitetura Hexagonal \cite{freeman2009growing}, DCI \cite{reenskaug2009dci} e BCE \cite{jacobson1993object},as quais abordam o conceito de divisão de camadas a fim de atingirem os mesmos objetivos. São arquiteturas: 

\begin{itemize}
    \item Independentes de \textit{frameworks};
    \item Testáveis;
    \item Independentes da Interface de Usuário;
    \item Independente do Banco de dados;
    \item Independente de qualquer fator externo.
\end{itemize}

Segundo Martin, a Arquitetura Limpa surgiu da "integração de todas essas arquiteturas em uma única ideia executável" \cite{arquiCleanArch}. Com isso, é de fácil compreensão o motivo pelo o qual a Arquitetura Limpa serviu de inspiração para a que será exposta na subseção \ref{sec:description}.

Para entender a Arquitetura Limpa, pode-se observar a Figura \ref{fig:clean}. A ideia geral por trás da arquitetura é ter camadas centrais que são raramente alteradas e desconhecem as camadas externas a elas. Quanto mais externa, mais concreta e ligada à plataforma de uso é a camada. Exemplificando: as entidades são representações de estruturas do domínio de seu software, então, independente de qualquer linguagem, programa, plataforma ou qualquer decisão nesse sentido, as entidades de seu programa não serão alteradas. Essa dinâmica é representada na Figura \ref{fig:cleanCone}.

\begin{figure}[h]
    \caption{Clean Architecture - Arquitetura Limpa}
    \centering
    \includegraphics[width=1\textwidth]{img/cleanArch.png}
    \fonte{\cite{arquiCleanArch}}
    \label{fig:clean}
\end{figure}

\begin{figure}[h]
    \caption{Clean Architecture Cone - Cone da Arquitetura Limpa}
    \centering
    \includegraphics[width=1\textwidth]{img/cleanArchCone.png}
    \fonte{\cite{arquiCleanStack}}
    \label{fig:cleanCone}
\end{figure}

\newpage


\section{Fundamentos de decisão de projeto}
\label{sec:Fundamentos}

Nesta seção serão elencados os principais fundamentos para as decisões de projeto que foram tomadas para o desenvolvimento da arquitetura proposta.

Conforme mencionado na seção \ref{sec:mvvm}, a arquitetura MVVM é facilmente testável e a atualmente recomendada pela google, porém possui a falha de não ter uma manutenibilidade tão boa quanto à MVP \cite{arquiMVVM}.

Com intuito de ter uma arquitetura facilmente testável, porém também com fácil manutenção, objetiva-se fazer uma adaptação da MVVM ao mesclar com a arquitetura Limpa. Ao realizar essa mescla, a Separação de Conceitos da arquitetura Limpa ajudará com a aplicação de todos os princípios SOLID \cite{arquiCleanArch}.

Além dos princípios SOLID, outros pontos relevantes para a fundamentação da arquitetura são: 

\begin{itemize}
    \item padrão de projeto \textit{Observer}: esse padrão de projeto possibilita a comunicação intermodular reduzindo o acoplamento uma vez que somente o módulo observador precisa conhecer o módulo observado.
    \item telas sem textos ou valores padrão fixos: com esses dados sendo injetados por um módulo específico ou sendo enviados pelo \textit{back-end}, a manutenção torna-se mais simples e dinâmica para qualquer plataforma que consuma esse módulo. A manutenção será feita somente em um local ao invés de dois (no caso de plataformas Android e iOS).
    \item padronizar a criação de novas telas: facilita a manutenção uma vez que, o fluxo de criação e todas as classes referentes a cada funcionalidade, possuem o mesmo padrão de desenvolvimento e estrutural.
\end{itemize}


\subsection{Arquitetura movida a estados}

Uma arquitetura movida a estados aumenta a segurança do software por ter regras bem definidas para cada estado do software \cite{arquiEstados}. O padrão de projeto \textit{State} é a base dessa proposta e para a utilização dele na arquitetura foi definido os seguintes estados para uma tela: Carregando, Erro, Sucesso e Ocioso. A utilização de cada estado se dá por:

\begin{itemize}
    \item Carregando: a tela está aguardando atualização de dados.
    \item Erro: a atualização de dados terminou com falha.
    \item Sucesso: a atualização de dados terminou com sucesso.
    \item Ocioso: aguardando \textit{input} do usuário após estado Sucesso.
\end{itemize}

O fluxo de estados está exemplificado da figura MAQUINHA ESTADOS. Com ele pode-se garantir que telas padronizadas de carregamento e de erro não serão exibidas incorretamente para o usuário.

Outra parte importante é que toda alteração de estado deverá ser enviada para um \textit{stream} ou fluxo de estados. Esse fluxo é observado a fim de que clientes desse fluxo, sejam notificados dessa atualização. O padrão de projeto \textit{Observer} foi utilizado nesse caso. O benefício dele é o baixo acoplamento entre o fluxo observado, A, e o observador, B, de forma que A não precisa conhecer ou ser dependente do B.

Ademais, toda tela deverá ter um modelo de dados que a represente por inteiro. Por exemplo, um tela que possua título, texto e um botão, deverá ter um modelo de dados que tenha uma propriedade para armazenar seu título, texto e o texto do botão. Dessa forma as informações poderão vir de provedores de informação, conforme será abordado na subseção \ref{sub:provedores}. Além dessas propriedades todo modelo de dados que represente uma tela deverá possuir um campo \textit{status} que representará o estado atual da tela (Carregando, Erro, Sucesso e Ocioso). O exemplo dado pode ser observado na figura LINKAR FIGURA MODELO TELA COM STATUS.

\subsection{Regras de negócio são compartilhadas}

Considerando que o funcionamento de qualquer aplicação, independente do sistema operacional, deva funcionar de acordo com as mesmas regras de negócio. É de fácil compreensão que o compartilhamento das regras de negócio beneficiará o desenvolvimento e a manutenção da aplicação. Seguindo essa proposta, o código será desenvolvido somente uma vez e, dessa forma, também deverá ser alterado somente em um local para qualquer tipo de manutenção. Ademais, ao se utilizar uma mesma fonte para todas as regras de negócio, uma atenção maior poderá ser dada à esse desenvolvimento, assim reduzindo a quantidade de \textit{bugs} presentes nessa parte.


\subsection{Provedores de informação}
\label{sub:provedores}

É comum que textos exibidos em tela e valores padrão sejam fixados nas aplicações móveis. Contudo, isso torna as aplicações mais rígidas e intolerantes a simples alterações ortográficas ou novas decisões de implementação. São exemplos dessas alterações: correção de um erro ortográfico; modificação de uma frase que está confundindo os usuários; ou usuários eram limitados a criar um apelido de no máximo 5 caracteres passaram a poder utilizar até 10 caracteres. Todas essa situação acarretam no lançamento de uma nova versão do aplicativo, lançamento que é um processo custoso e depende da aprovação dos reguladores das lojas dos aplicativos (Google no caso de Android e Apple no caso de iOS).

Como solução do problema, foi-se utilizado a ideia de "provedores de informação". Esses provedores são responsáveis por realizar chamadas ao \textit{back-end} para que ele retorne as infromações para os aplicativos. Essas informações seriam: títulos, textos, valores das \textit{labels} de formulários, valores padrão de objetos (todo usuário começará com o apelido igual ao seu primeiro nome, ou limite máximo de caracteres no apelido) e etc. Com isso, o custo de ter que lançar todo um app novo para realizar essas pequenas alterações é evitado. Além disso é garantido que todos esses valores serão os mesmos para qualquer plataforma.

Um ponto de observação é que nem toda equipe irá aceitar a proposta do \textit{back-end for front-end} mencionada no parágrafo anterior. A sugestão nesse caso seria continuar utilizando um "provedor de informação", porém que busque esses valores em um local fixo. Dessa forma o aplicativo continuará se beneficiando da centralização desses valores, de forma que qualquer plataforma consuma de um mesmo local, porém com o custo de ter que lançar uma nova versão do app para esse tipo de alteração.

\newpage

\section{Descrição da arquitetura proposta}
\label{sec:description}
A arquitetura proposta será divida em dois grandes módulos, a partir de uma abstração genérica da arquitetura MVVM, já utilizada e verificada pelo uso público. Neste modelo de inspiração, o primeiro módulo é o \textit{Model}, que representa toda a parte de entidades e regras de negócio, enquanto o segundo é a junção da \textit{View} e \textit{ViewModel} de forma que exista um módulo específico e responsável pela visualização e regras de apresentação ao usuário.

De forma genérica e, por enquanto, abstrata, os dois módulos da arquitetura proposta, conforme se visualiza na Figura \ref{fig:propostaArquitetura}, podem ser definidos em:

\begin{enumerate}
    \item \textit{Presentation}: é o modulo responsável pela apresentação e regras de interação com o usuário. Ele é totalmente dependente da plataforma que se está utilizando. De modo que, para um desenvolvimento multiplataforma no contexto Android e iOS, tudo que for implementado dentro desse módulo para Android deverá ser reimplementado para iOS.
    
    \item \textit{Domain}: baseado no Model da arquitetura MVVM e utilizando-se dos princípios da Arquitetura Limpa. Ele é o módulo central da arquitetura, de forma que deverá ser totalmente independente da plataforma de implementação. Com isso, poderá ser completamente intercambiável entre Android e iOS, de modo que consistirá na representação multiplataforma nessa arquitetura.
\end{enumerate}

\begin{figure}[h]
    \caption{Proposta Geral da Arquitetura}
    \centering
    \includegraphics[width=.6\textwidth]{img/Arquitetura Basica - Interacao.png}
    \fonte{Própria}
    \label{fig:propostaArquitetura}
\end{figure}

\subsection{Visão por estrutura}
Seguindo a descrição da arquitetura será apresentado agora uma visão por estruturas. Com ela será possível compreender as responsabilidades individuais de cada módulo. Na figura FIGURA ESTRUTURA é exibida a primeira divisão da arquitetura. Cada uma das estruturas serão explicadas a seguir.

IMAGEM

\textit{View} é a estrutura que representa o Presentation da figura \ref{fig:propostaArquitetura}, porém com um nome que se aproxima dos utilizados em desenvolvimento. Assim como o Presentation, ela representa a parte exclusiva de cada plataforma, com isso, sua organização interna pode ser modificada para atender melhor cada uma. Por exemplo, em Android, a divisão em \textit{Fragment} e \textit{ViewModel} é bem comum e recomendada pela Google, então a estrutura \textit{View} será dividida em outras duas: \textit{Fragment} e \textit{ViewModel}; já em iOS a \textit{Viem} pode ser representada por somente uma estrutura, a \textit{ViewController}. Sendo assim, essa estrutura deverá somente receber interações do usuário e repassá-las para o \textit{Interactor}. E, como comentado anteriormente, deverá observar o \textit{Interactor} para reagir às atualizações de estado.

\textit{Interactor} é estrutura de entrada para a parte compartilhada do código. É somente com ela que a parte exclusiva de cada SO deverá se comunicar. Para que essa comunicação seja realizada é no interactor que o fluxo de estados está. Em outras palavras o \textit{Interactor} é a parte observada e a \textit{View} é o observador do padrão \textit{Observer} comentado anteriormente. Além disso, para realizar as atualizações de estado com as ações informadas pela \textit{View} é necessário que o \textit{Interactor} conheça toda a regra de negócio. Seguindo assim, ele é a estrutura compartilhada responsável por manter a integridade das ações do usuário de acordo com a regras de negócio estabelecidas.

\textit{Model} é a estrutura central da aplicação. Ela representa todos os modelos de dados da aplicação, e, assim como foi comentado anteriormente, toda tela deverá ter um modelo de dados que a represente por inteiro. Dessa forma esse modelo de dados é o que será utilizado para manter os estados no fluxo de estados presente no \textit{Interactor}. Ademais, por ser o centro da aplicação, ela pode ser acessada por todas as estruturas, contudo, para o correto funcionamento da arquitetura, somente o \textit{Interactor} deverá atualizar esse modelo com novas informações.

\textit{Provider} são os "provedores de informação" comentados na subseção CITAR CUBSEÇÂO. Eles são os reponsáveis por conhecer implementações de requisições ao \textit{back-end}, banco de dados, possuir dados fixos\footnote{Como comentado anteriormente, se a equipe não optar por utilizar o \textit{back-end for front-end} dados fixos num provedor de informações é uma solução superior a dados fixos na parte não compartilhada do código}, e etc. Nessa primeira instância a estrutura foi unida em uma só, porém ela será subdividida em interface e implementação. Essa divisão será feita para aplicar o princípio de Inversão de Dependência, uma vez que torna o \textit{Interactor}, camada central, independente da implementação de seu "provedor de informação".

Dado a explicação teórica de cada estrutura, será apresentado a seguir um caso de uso da arquitetura proposta.

\subsection{Casos de uso}

Serão apresentados 3 casos de uso para essa arquitetura. Todos os casos são referentes a aplicativo bancário e de simples entendimento. O primeiro caso é sobre a funcionalidade de transferência em que o usuário abre a tela de transferência em seu aplicativo, insere o valor que deseja transferir e clica no botão para realizar a transferência. O segundo é uma tela utilizada para consultar o saldo presente na conta corrente do usuário. Nele o usuário simplesmente abre a tela para consultar seu saldo, o qual deverá ser atualizado com um serviço remoto. No terceiro caso de uso será apresentando o \textit{onboarding} do aplicativo em que o usuário receberá informações de como utilizar o app. Como decisão prévia esse \textit{Onboarding} deverá ser realizado somente quando for a primeira vez do usuário ao acessar o app no dispositivo. Para atender essa demanda a visualização do \textit{onboarding} será salva em um banco local no dispositivo do usuário.

Primeiro caso de uso, transferência. Na figura CITAR TRANSFERNECIA pode-se observar que a estrutura \textit{View} foi adaptada para uso de acordo com cada plataforma. Em Android temos que ela foi subdividida em TransferenciaFragment e TransferenciaViewModel; já no iOS temos somente uma classe para TranferênciaViewController. Tanto iOS quanto Android irão se comunicar com o \textit{Interactor} por meio da função \textit{onTransfer()}. O \textit{Interactor} realizará validações seguindo a regra de negócio, por exemplo, conferir se o valor a ser transferido está no intervalo maior que zero e menor ou igual ao valor disponível para transferência; após essa validação atualizará seu estado para Carregando e irá executar a função \textit{transfer()} da interface TransferenciaProvider. Essa função é implementada pela TransferenciaProviderRemote que irá efetivamente realizar o pedido de transferência ao serviço externo. Ao receber a resposta do serviço, a retornará para o \textit{Interactor} que, em caso de sucesso, atualiza seu estado para Sucesso e, caso contrário, atualiza seu estado para Erro; de forma que TransferenciaViewModel e TransferenciaViewController possam reagir à atualização de estados. Nesse processo todo o modelo de dados TransferenciaScreen será utilizado para atualizar os estados no TransferenciaInteractor.

IMAGEM

Ainda no primeiro caso de uso, mas para uma melhoria proposta têm-se a figura CITAR IMAGEM. Nela observa-se que cada um das classes e interfaces estendem de sua respectiva classe base. Essa classe base é utilizada para realizar comportamentos comuns à toda estrutura de seu tipo. Por exemplo, a classe BaseFragment pode ser utilizada para ocultar o processo de inflar os \textit{layouts} em Android; o BaseInteractor pode ser utilizada para iniciar o fluxo de estados; o BaseScreen para conter a propriedade \textit{Status}, que é pertinente para todos os modelos de tela. Esse processo de criação de classes base aumenta a qualidade estática do software uma vez que oculta e evita repetições de processos. Com isso, o princípio Aberto/Fechado é atendido uma vez que novas funcionalidades são incluídas a partir de novo código e sem a alteração de código já existente conforme será exemplificado no próximo caso de uso.

IMGEM BASE

Segundo caso de uso, consulta saldo. A separação de estrutura e criação de classes foi feita da mesma forma que o primeiro caso de uso. As estruturas de classes continuam as mesmas, tanto que a figura CITAR CONSULT só se difere da figura CITAR TRANS no prefixo das classes, onde estava escrito Transferencia está agora escrito ConsultaSaldo. Essa é uma observação relevante a ser feita, pois demonstra que a arquitetura continua exatamente a mesma para um outro caso de uso, em outras palavras, uma funcionalidade pode ser utilizada como \textit{template} para outra. Agora, para uma visualização de forma integrada do primeiro caso de uso com o segundo, pode-se observar a figura (CITAR INTEGRAÇÂO)

IMAGEM BASE CON

IAMGE BASE INTEGRADO

Terceiro caso de uso, \textit{onboarding}. De acordo com o plano para essa funcionalidade, o aplicativo necessitará de acesso a um banco local que não foi mapeado nos exemplos anteriores. Com isso podemos verificar a facilidade de inclusão de novos módulos que a Arquitetura Limpa e os princípios SOLID trazem. Toda a funcionalidade de \textit{onboarding} será parecida com os outros dois casos de uso. Terá a implementação da \textit{View} de acordo com seu SO, um \textit{Interactor}, um modelo de dados que represente a tela e uma interface provedora de informações. Contudo, a implementação dessa interface será incluída num novo módulo de provedores locais. A figura CITAR INTEGRAÇÂO COMPLETA mostra que essa nova integração não altera em nada os módulos já existentes que continuam a existir sem o conhecimento que um novo módulo foi incluído.

IMAGEM INTEGRAÇAÔ COMPLETA