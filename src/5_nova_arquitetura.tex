\chapter[Descrição Preliminar da Arquitetura Proposta]{Descrição Preliminar da Arquitetura Proposta}
\label{cap:novaArquitetura}

A proposta da nova arquitetura tomou como base principalmente outras duas, a \textit{Model-View-ViewModel} (MVVM) e a \textit{Clean Architecture} \cite{arquiMVVMGoogle, arquiCleanArch}. Essas duas arquiteturas serão descritas nas seções \ref{sec:mvvm} e \ref{sec:clean}, entretanto para um melhor entendimento é recomendado a leitura referenciada de cada uma.

\section{Arquitetura \textit{Model-View-Viewmodel}}
\label{sec:mvvm}

Trata-se de uma arquitetura criada por Ken Cooper e Ted Peters, sendo atualmente recomendada pela Google para o desenvolvimento de aplicações nativas em Android. Anteriormente, até 2010, a arquitetura recomendada era a \textit{Model-View-Controller}, mas, por dificuldades de manutenção e testes, a Google passou a recomendar a MVVM ou \textit{Model-View-Presenter}. Por meio do artigo "\textit{A comparison of Android Native App Architecture MVC, MVP and MVVM}", foi realizada a comparação entre as 03 (três) arquiteturas, ocasião na qual conclui-se que tanto a MVVM quanto MVP possuem ganhos significativos quando comparadas com a MVC. Já entre MVVM e MVP, não houve uma resposta clara acerca de qual seria a melhor, mas foi concluído que MVVM é mais facilmente testável, enquanto a MVP tinha uma manutenibilidade melhor \cite{arquiMVVM, arquiMVVMGoogle}.

Dado o exposto, tem-se que a escolha entre MVVM e MVP se baseiam no domínio do problema e no consenso entre os desenvolvedores a respeito de qual característica é a mais relevante para seu projeto. Todavia, sistemas em que testes são realizados mais facilmente são melhor testados, logo, possuem menos erros críticos em produção, de forma que as manutenções que serão realizadas para correção de tais erros dispõem de um tempo maior. Deste modo, a arquitetura MVVM foi a escolhida para ser utilizada como uma das inspirações dessa nova arquitetura que será apresentada na subseção \ref{sec:description}.

A representação de alto nível da arquitetura pode ser observada na Figura \ref{fig:mvvm}. A partir dela, é possível compreender que a \textit{View} e a \textit{ViewModel}, representados, respectivamente, na figura por \textit{Activity/Fragment} e \textit{ViewModel}, são responsáveis pela visualização e lógica de visualização do software. Já o agrupamento do \textit{Repository}, \textit{Model} e \textit{Remote Data Source} gerenciam as partes de modelo de dados, regras de negócio e requisição de dados local e remoto. Esse agrupamento foi abstraído para o nome \textit{Model}, que está presente no nome da arquitetura. 


\begin{figure}[h]
    \caption{Arquitetura Model-View-Viewmodel}
    \centering
    \includegraphics[width=.85\textwidth]{img/mvvm.png}
    \fonte{\cite{arquiMVVMGoogle}}
    \label{fig:mvvm}
\end{figure}


\section{Arquitetura Limpa - \textit{Clean Architecture}}
\label{sec:clean}

A \textit{Clean Architecture} ou Arquitetura Limpa foi desenvolvida por Robert Martin \cite{arquiCleanArch} tem como foco a \textit{Separation of Concerns}, ou Separação de Conceitos, fazendo com que todos os conceitos SOLID explicados anteriormente sejam seguidos. Ademais, promove a "[...] implementação de sistemas que favorecem reusabilidade de código, coesão, independência de tecnologia e testabilidade." \cite{arquiEngSoftModerna}.

Essa arquitetura utiliza-se de outras arquiteturas conhecidas como: Arquitetura Hexagonal \cite{freeman2009growing}, DCI \cite{reenskaug2009dci} e BCE \cite{jacobson1993object},as quais abordam o conceito de divisão de camadas a fim de atingirem os mesmos objetivos. São arquiteturas: 

\begin{itemize}
    \item Independentes de \textit{frameworks};
    \item Testáveis;
    \item Independentes da Interface de Usuário;
    \item Independente do Banco de dados;
    \item Independente de qualquer fator externo.
\end{itemize}

Segundo Martin, a Arquitetura Limpa surgiu da "integração de todas essas arquiteturas em uma única ideia executável" \cite{arquiCleanArch}. Com isso, é de fácil compreensão o motivo pelo o qual a Arquitetura Limpa serviu de inspiração para a que será exposta na subseção \ref{sec:description}.

Para entender a Arquitetura Limpa, pode-se observar a Figura \ref{fig:clean}. A ideia geral por trás da arquitetura é ter camadas centrais que são raramente alteradas e desconhecem as camadas externas a elas. Quanto mais externa, mais concreta e ligada à plataforma de uso é a camada. Exemplificando: as entidades são representações de estruturas do domínio de seu software, então, independente de qualquer linguagem, programa, plataforma ou qualquer decisão nesse sentido, as entidades de seu programa não serão alteradas. Essa dinâmica é representada na Figura \ref{fig:cleanCone}.

\begin{figure}[h]
    \caption{Clean Architecture - Arquitetura Limpa}
    \centering
    \includegraphics[width=1\textwidth]{img/cleanArch.png}
    \fonte{\cite{arquiCleanArch}}
    \label{fig:clean}
\end{figure}

\begin{figure}[h]
    \caption{Clean Architecture Cone - Cone da Arquitetura Limpa}
    \centering
    \includegraphics[width=1\textwidth]{img/cleanArchCone.png}
    \fonte{\cite{arquiCleanStack}}
    \label{fig:cleanCone}
\end{figure}

\newpage


\section{Fundamentos de decisão de projeto}
\label{sec:Fundamentos}


\newpage

\section{Descrição da arquitetura proposta}
\label{sec:description}
A arquitetura proposta será divida em dois grandes módulos, a partir de uma abstração genérica da arquitetura MVVM, já utilizada e verificada pelo uso público. Neste modelo de inspiração, o primeiro módulo é o \textit{Model}, que representa toda a parte de entidades e regras de negócio, enquanto o segundo é a junção da \textit{View} e \textit{ViewModel} de forma que exista um módulo específico e responsável pela visualização e regras de apresentação ao usuário.

Já a inspiração na Arquitetura Limpa se deu para detalhar mais a fundo as camadas internas e suas responsabilidades, a fim de garantir uma definição melhor e mais prática do que será contido em cada módulo para facilitar o entendimento e reprodução da arquitetura.

De forma genérica e, por enquanto, abstrata, os dois módulos da arquitetura proposta, conforme se visualiza na Figura \ref{fig:propostaArquitetura}, podem ser definidos em:

\begin{enumerate}
    \item \textit{Domain}: análago ao Model da arquitetura MVVM e utilizando-se dos princípios da Arquitetura Limpa, ele é o módulo central da arquitetura, de forma que deverá ser totalmente independente da plataforma de implementação. Com isso, ele poderá ser completamente intercambiável entre Android e iOS, de modo que consistirá na representação da multiplataforma nessa arquitetura.
    
    \item \textit{Presentation}: é o modulo responsável pela apresentação e regras de interação com o usuário. Ele é totalmente dependente da plataforma que se está utilizando de modo que, para um desenvolvimento multiplataforma no contexto Android e iOS, tudo que for implementado dentro desse módulo para Android deverá ser reimplementado para iOS.
\end{enumerate}

\begin{figure}[h]
    \caption{Proposta Geral da Arquitetura}
    \centering
    \includegraphics[width=.6\textwidth]{img/propostaArquitetura.png}
    \fonte{Própria}
    \label{fig:propostaArquitetura}
\end{figure}






Observação: informar todas as decisões tomadas com base em algum referencial teórico para nao parecer que tirou da cabeça. Principalmente na parte da descrição da arquitetura (justificativa na hora da descrição da arquitetura)  INFORMAÇÃO PERTO DE ONDE É ÚTIL


## Dar exemplos de cada camada (pode usar exemplos do banco)

Exemplo principal: Transferir dinheiro pelo aplicativo de celular


Models:

São classes de modelo da aplicação. Representam 1 pra 1 objetos reais do escopo. São livres de quaisquer regras de visualização, o foco é manter fidelidade ao mundo real

Objetos do dominio do problema

Ex: Conta Corrente do usuário


Providers:

São interfaces que responsáveis por buscar definir quais métodos irão buscar quais informações em repositórios locais ou remotos para atualizar Models com os valores reais. Quem utiliza a interface não sabe dos detalhes da implementação (não sabem se é acesso remoto ou local, qual tipo de protocolo utiliza, qual banco de dados acessa...)

Ex: Serviço para consultar saldo disponível. Serviço para requisitar a trasnferência do dinheiro


Interactors:

Classes que gerenciam as regras de negócio da aplicação, normalmente, tratando-se de aplicações frontend, regras de negócio são praticamente inexistentes acabam que se misturam um pouco com regras de visualização, num contexto de arquitetura multiplataforma o interactor será responsável também por regras de visualização para se manter a constancia em diversas plataformas. São as regras de negócio e de aplicação que garantem que nenhum princípio lógico pertencente ao escopo do projeto seja ferido ou violado, além de manter a aplicação funcionando conforme deveria.

Ex: 
    Regra de negócios: Cliente só pode acessar a conta corrente caso usuário e senha de login estejam corretos. Cliente só pode transferir dinheiro caso tenha saldo em conta suficiente para a transação.

    Regra de aplicação e visualização: cliente deve visualizar somente seu primeiro nome nas telas de transferência. Caso o cliente não possua saldo para transferência o botão "Transferir" deverá ficar desabilitado.


ViewModel

Responsáveis pela lógica de apresentação dos modelos e por enviar intenções de ações do usuário para os interactors. (CONTROLLER)


View:

A tela que o usuário realmente enxerga e interage sem nenhuma lógica envolvida.



Dependency Rule
Seguindo os princípios da clean architecture as dependências de software somente apontam e seguem o aumento de regras negociais. Ou seja, o model é o ponto que mais representa o negócio, logo não depende de nenhuma outra camada. Já a view não possui conhecimento negocial algum, logo é a que mais depende das outras camadas


Sequencia de ação:

View é criada -> ViewModel é instanciada e envia um intent de para buscar informações e renderizar a tela -> Interactors escutam o intent e pedem para os providers atualizarem o modelo ->



Tarefas:

- Descrever as camadas. Com exemplos de uso de um exibe saldo e saca 
- Criar os diagramas
    - Terminar o por camadas 
        -Inverter a ordem
        -Adicionar o usuário no fluxo
    - UML de classes
